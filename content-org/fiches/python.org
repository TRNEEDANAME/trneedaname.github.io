#+TITLE: Python
#+HUGO_BASE_DIR: ../../
#+HUGO_LAYOUT: page
#+FILETAGS: fiches python français
#+DATE: 2025-10-08
#+HUGO_PUBLISHDATE: null
#+HUGO_DRAFT: false
#+HUGO_SECTION: fiches
#+AUTHOR: TRNEEDANAME
#+macro: relref @@hugo:[@@ $1 @@hugo:]({{< relref "$2" >}})@@

** Le Python, c'est quoi ?

#+begin_info
Le langage =Python= est un langage dit =interprété=, ce qui veut dire que chaque instruction est lue ligne par ligne, de haut en bas.  
Le code est compilé au moment de l’exécution.
#+end_info

#+begin_memo Convention
Le python utilise le [[https://fr.wikipedia.org/wiki/Snake_case][Snake Case]] pour nommer les variables, par exemple, une variable serait donc ~ma_variable~.

Il est important d'être explicite, par exemple :

#+begin_src python
def func(valeur):
    return (valeur % 4 == 0) and (valeur % 100 != 0 or valeur % 400 == 0)

val = int(input("Quelle année voulez vous tester"))
res = func(val)

if (res):
    print(f"L'année {val} est bien bissextile !")
else:
    print(f"L'année {val} n'est pas bissextile !")

#+end_src

Même si cela compile et exécute, il est bien mieux d'écrire

#+begin_src python
def est_anne_bissextile(annee):
    # Les années bissextiles sont toutes des multiples de 4
    if annee % 4 != 0:
        return False
    # Les années séculaires ne sont pas bissextiles, hormis 1600, 2000, 2400, etc.
    if annee % 100 == 0:
        return annee % 400 == 0
    # Tous les autres résultats sont vrais.
    return True

annee = int(input("Quelle année voulez vous tester"))
resultat = est_anne_bissextile(annee)

if (resultat):
    print(f"L'année {annee} est bien bissextile !")
else:
    print(f"L'année {annee} n'est pas bissextile !")

#+end_src

Ce code paraît plus "verbeux" mais il est bien plus lisible !

#+begin_important L'indentation
Python utilise l'indentation pour marquer si du code appartient à une condition, une boucle, une fonction ou une classe.
#+end_important

Toutes les conventions sont disponibles sur [[https://www.w3schools.com/python/python_syntax.asp][W3School]] et [[https://peps.python.org/pep-0008/][Python Style Guide]].

#+end_memo

** Les types et variables

#+begin_src python
age = 20
nom = "Tom"
etudiant = True
animaux = ["chien", "chat", "poisson", "chameau"]

print(age)
print(nom)
print(f"Le type de la variable 'age' est {type(age)} alors que le type de 'nom' est {type(nom)}")
#+end_src

Comme montré, Python n'a pas de =types= prédéfinis comme d'autres langages (Java, C++, C, ...). Les types sont définis par l'interpréteur.  
Cela permet de redéfinir les types à la volée.

*** Redéfinitions des types

#+begin_tip Les types
#+begin_src python 
age = 20
print(type(age) == str)
print("Changement de la variable 'age' en string")
age = "tomate"
print(age)
print(type(age) == str)
#+end_src
#+end_tip

#+begin_tip Booléens
Pour les vérifications booléennes (~True~ ou ~False~), utiliser ~==~ peut être remplacé par ~is~ pour plus de lisibilité.
Les vérifications fausses sont donc ~is not~.
#+End_tip

#+begin_warning Attention
Avec des ~int~ cela renvoie une ~SyntaxWarning~, ce n'est pas une erreur en soit mais à éviter.

~SyntaxWarning: "is" with 'int' literal. Did you mean "=="?~
#+end_warning

Comme vous pouvez le voir, le résultat est le même.

#+begin_src python 
nom = "Tom"
print(type(nom) == str)
print(type(nom) == bool)
print("Utilisation de 'is' et 'is not'")
print(type(nom) is str)
print(type(nom) is bool)
#+end_src

*Utiliser ~is~ fonctionne quant même.*

#+begin_src python 
print(type(4) is str)
#+end_src

** Les entrées / sorties

*** L'entrée

Dans tout les language l'~I/O~ (input / output) est très commun, le python rend cela très simple :

#+begin_src python 
nom = input("Quel est votre nom ? ")
print(f"Bonjour {nom} !")
#+end_src

#+begin_tip - String & f-string
La fonction ~print()~ peut paraître un peu différente.  
J'utilise des ~f-strings~ qui permettent d'insérer des variables directement dans les chaînes de caractères avec ~{}~.
#+end_tip

Pour demander un nombre il faut mettre le ~input()~ dans un ~int()~ ou autre.

#+begin_src python 
age = input("Quel est votre age ? ")
age = age + 1
print(age)
print(type(age))
#+end_src

#+begin_error Erreur
Comme vous le voyez en exécutant le code, l'interpréteur de Python renvoie

~TypeError: can only concatenate str (not "int") to str~
#+end_error

Avec le ~input()~ transformé :

#+begin_src python 
age = int(input("Quel est votre age ? "))
age = age + 1
print("Votre age est donc " + age)
#+end_src

*** La sortie

#+begin_src python 
print("Hello World !")
#+end_src

Le python supporte la concaténation des string, par exemple

#+begin_src python 
age = 20
print("J'ai " + str(age) + " ans")
#+end_src

#+begin_tip - A voir
La variable ~age~ à du être entouré dans une autre fonction ~str()~, elle transforme le ~int~ en ~string~
#+end_tip

** Les fonctions

Les fonctions sont des blocs de code réutilisables.

#+begin_src python 
def ma_fonction(age):
    age = age + 1
    print(f"Vous avez {age} ans")

ma_fonction(int(input("Quel est votre âge ?")))
#+end_src


#+begin_note Décomposition
- ~def~ définit le début d'une fonction.  
- ~ma_fonction~ est le nom de la fonction.  
- ~(age)~ est un paramètre. Dans cet exemple, on prend l'âge en paramètre et on lui ajoute ~1~.
#+end_note
  
#+begin_idea Tabulations
Comme dit plus haut le Python utilise l'indentation : tout ce qui est indenté après le ~def~ est considéré comme faisant partie de la fonction.
#+end_idea

#+begin_src python 
def ma_fonction(age):
    print(f"J'avais {age} ans")
    age = age + 1
    print(f"J'ai {age} ans")

mon_age = 20
ma_fonction(mon_age)
#+end_src

On peut créer des fonctions avec un nombre illimité de paramètres, par exemple :

#+begin_src python 
def ma_super_longue_fonction(age, nom, formation, lycee):
    print(f"Je m'appelle {nom}, j'ai {age} ans et je suis en {formation} à {lycee}")

age = 20
nom = "Tom"
formation = "BTS SIO"
lycee = "Gaston Berger"

ma_super_longue_fonction(age, nom, formation, lycee)
#+end_src

** Les conditions

Une condition vérifie si ce que vous demandez est ~vrai~ (~True~) ou ~faux~ (~False~).

#+begin_src python 
age = 20

if age < 18:
    print("Tu es mineur")
else:
    print("Tu n'es pas mineur")
#+end_src

#+begin_notes Décomposition
- ~if~ vérifie si une valeur est :  
  - égale  
  - plus grande (strictement ou non)  
  - plus petite (strictement ou non)  
- ~else~ est exécuté si la condition est fausse  
#+end_notes

Si la condition n'est pas vraie mais que l'on veut tester d'autres conditions, on utilise ~elif~.

#+begin_src python
nombre = 42
if nombre == 42:
    print("Le nombre est bien la vie")
elif nombre < 42:
    print("Le nombre est inférieur")
elif nombre > 42:
    print("Le nombre est supérieur")
elif nombre <= 42:
    print("Le nombre est strictement inférieur")
elif nombre >= 42:
    print("Le nombre est strictement positif")
else:
    print("Autre")
#+end_src

*** Chainage de condition

Les conditions peuvent être enchaînées.

- ~and~ signifie "et"  
- ~or~ signifie "ou"

#+begin_src python
age = 20

if age > 18 and age < 25:
    print("L'âge est compris entre 18 et 25")
elif age > 18 or age < 25:
    print("L'âge est supérieur à 18 ou inférieur à 25")
#+end_src

** Les boucles

*** Boucle for

Boucle qui itère sur une séquence.

Tant que le tableau a des valeurs, on affiche chaque élément

#+begin_experiment Exemple n°1
#+begin_src python
tableau = [0, 1, 2, 3, 4, 5, 6]

for i in tableau:
    print(i)
#+end_src

#+begin_note Décomposition
- ~for~ : boucle qui itère sur chaque élément d'une séquence.
- ~i~ : variable représentant l'élément courant.
- ~in~ : définit sur quelle séquence la boucle s'exécute.
Tant que nous sommes dans la plage [0;10], on affiche la valeur.
#+end_note

#+end_experiment

#+begin_experiment Exemple n°2
#+begin_src python
for i in range(0, 10):
    print(i)

#+end_src
#+begin_note Décomposition
- ~range~ : fonction qui renvoie une séquence entre deux valeurs

A savoir que ~range()~ n'inclut pas la valeur de fin
#+end_note
#+end_experiment

*** Boucle while

Boucle qui s'exécute tant que la condition est vraie.


#+begin_experiment Exemple n°1
Tant que la valeur est inférieure à 5, on l'affiche et on l'incrémente

#+begin_src python
i = 0
while i < 5:
    print(i)
    i += 1
#+end_src

#+begin_note Décomposition
- ~while~ : boucle qui continue tant que la condition est vraie  
- ~i < 5~ : condition d'arrêt  
- ~i += 1~ : incrémente la variable pour éviter boucle infinie
#+end_note
#+end_experiment


#+begin_experiment Exemple n°2
Tant que la liste n'est pas vide, on retire et affiche le premier élément

#+begin_src python
liste = [10, 20, 30, 40]
while liste:
    print(liste.pop(0))
#+end_src

#+begin_note Décomposition
- ~liste~ : la séquence sur laquelle on travaille  
- ~while liste~ : boucle continue tant que la liste n'est pas vide  
- ~pop(0)~ : retire le premier élément et le retourne
#+end_note

#+end_experiment
