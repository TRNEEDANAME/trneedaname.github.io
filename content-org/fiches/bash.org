#+TITLE: Bash
#+HUGO_BASE_DIR: ../../
#+HUGO_LAYOUT: page
#+AUTHOR: TRNEEDANAME
#+FILETAGS: fiches bash
#+DATE: 2025-11-05
#+HUGO_PUBLISHDATE: null
#+HUGO_DRAFT: true
#+macro: relref @@hugo:[@@ $1 @@hugo:]({{< relref "$2" >}})@@
#+HUGO_SECTION: fiches

** Le Bash, c’est quoi ?

Le langage =Bash= (Bourne Again SHell) est un langage de script interprété par un terminal Unix/Linux.  
Il sert principalement à automatiser des tâches système, manipuler des fichiers, exécuter des commandes, etc.

Le Bash est un language de programmation, mais en tant que tel il n'est pas très utile, il est principalement utilisé en conjonction avec des commandes qui permettent d'interagir avec le système.

Ces commandes (ainsi que le Shell) sont installé par défaut sur la plupart des distribution Linux.

#+begin_info Le manuel
Si vous utilisez une distribution Linux (ou WSL sur windows / une VM), la commande ~man~ va être très utile, ~man commande~ vous donne le manuel de la commande en question, ce qui est pratique (surtout pour les différents flags et autre fonctions)
#+end_info

#+begin_memo Convention
Les scripts Bash ont généralement l’extension =.sh= et commencent toujours par une ligne d’en-tête (appelée *shebang*) :

#+begin_src bash
#!/bin/bash
#+end_src

Les conventions recommandent :
- d’utiliser des *minuscules* pour les noms de variables et de fonctions ;
- de séparer les mots par des underscores ~_~ :  
  ~ma_variable~, ~ma_fonction()~ ;
- Pas d'espaces entre les affectations :
  ~x=10~ (et non ~x = 10~).
#+end_memo

** Les variables

#+begin_src bash
#!/bin/bash

nom="Tom"
age=20
etudiant=true

echo "Nom : $nom"
echo "Âge : $age"
echo "Étudiant : $etudiant"
#+end_src

#+begin_tip À savoir
- Pas d’espace avant ou après ~=~
- Pour utiliser une variable, on écrit ~$nom_variable~
- Les variables sont toujours des chaînes de caractères, même si elles contiennent des nombres
#+end_tip

*** Les tableaux

#+begin_src bash
animaux=("chien" "chat" "poisson" "chameau")

echo "Premier animal : ${animaux[0]}"
echo "Tous les animaux : ${animaux[@]}"
echo "Nombre d'animaux : ${#animaux[@]}"
#+end_src

#+begin_tip À savoir
Les indices commencent à 0.  
~[@]~ permet d’afficher tous les éléments, ~#~ donne la taille du tableau.
#+end_tip

** Entrées / sorties

*** Les entrées

Lire une valeur entrée par l’utilisateur avec ~read~ :

#+begin_src bash
read "Quel est ton nom ? " nom
echo "Bonjour $nom !"
#+end_src

*** Les sorties

Afficher un texte avec ~echo~ :

#+begin_src bash
echo "Hello World !"
#+end_src

#+begin_note Options utiles
- ~-n~ : n’ajoute pas de retour à la ligne  
- ~-e~ : permet d’interpréter les caractères spéciaux comme ~\n~ (nouvelle ligne)
#+end_note

** Les conditions

#+begin_src bash
read -p "Quel est ton âge ? " age

if [ "$age" -lt 18 ]; then
  echo "Tu es mineur."
elif [ "$age" -eq 18 ]; then
  echo "Tu viens d’avoir la majorité !"
else
  echo "Tu es majeur."
fi
#+end_src

#+begin_tip À savoir
- Les crochets ~[~ et ~]~ entourent les conditions (avec espaces obligatoires)  
- Les opérateurs numériques :  
  ~-lt~ (~<~), ~-le~ (~<=~), ~-gt~ (~>~), ~-ge~ (~>=~), ~-eq~ (~=~), ~-ne~ (~!=~)
- Les chaînes de caractères :  
  ~==~, ~!=~, ~-z~ (vide), ~-n~ (non vide)
#+end_tip

** Les boucles

*** Boucle for

#+begin_src bash
for i in {1..5}; do
  echo "Itération $i"
done
#+end_src

#+begin_tip Info
Les boucles utilise ~..~ pour donner un début et une fin

~1..5~ va de ~1~ à ~5~ (inclut)
#+end_tip

*** Boucle while

#+begin_src bash
i=0
while [ $i -lt 5 ]; do
  echo "Valeur : $i"
  ((i++))
done
#+end_src

*** Boucle until

#+begin_src bash
i=0
until [ $i -ge 5 ]; do
  echo "Compteur : $i"
  ((i++))
done
#+end_src

** Les fonctions

#+begin_src bash
ma_fonction() {
  echo "Hello depuis une fonction !"
}

ma_fonction
#+end_src

#+begin_note Avec paramètres
#+begin_src bash
dire_bonjour() {
  nom=$1
  echo "Bonjour $nom !"
}

dire_bonjour "Alice"
dire_bonjour "Bob"
#+end_src
#+end_note

** Les cas (switch)

#+begin_src bash
read -p "Entre une lettre : " lettre

case $lettre in
  a|e|i|o|u|y)
    echo "C'est une voyelle"
    ;;
  *)
    echo "Pas une voyelle"
    ;;
esac
#+end_src

#+begin_note Décomposition
- Chaque *motif* est séparé par ~|~  
- ~;;~ marque la fin d’un bloc  
- ~*~ correspond au cas par défaut  
- ~esac~ termine la structure
#+end_note

** Les tests de fichiers

#+begin_src bash
fichier="test.txt"

if [ -f "$fichier" ]; then
  echo "Le fichier existe."
else
  echo "Le fichier n'existe pas."
fi
#+end_src

#+begin_note Options utiles
- ~-f~ : fichier régulier  
- ~-d~ : dossier  
- ~-e~ : existe  
- ~-r~, ~-w~, ~-x~ : lisible, modifiable, exécutable
#+end_note

** Piping et redirections

Les pipes (~|~) permettent d’envoyer la sortie d’une commande comme entrée d’une autre commande.  
Les redirections (~>~, ~>>~, ~<~) permettent de manipuler les flux d’entrée/sortie.

#+begin_src bash
# Exemple simple : envoyer la sortie de `ls` à `grep`

# ls permet de lister tout les fichiers d'un dossier
ls | grep ".sh"

# Rediriger la sortie vers un fichier (écrase le contenue)
echo "Bonjour" > fichier.txt

# Ajouter sans écraser
echo "Encore une ligne" >> fichier.txt

# Lire depuis un fichier, équivalent à ~cat fichier.txt~
cat < fichier.txt
#+end_src

#+begin_note Décomposition
- ~|~ : utilise la sortie d'une commande comme l'entrée d'une autre
- ~>~ : écrit dans un fichier (écrase)  
- ~>>~ : ajoute à un fichier  
- ~<~ : lit à partir d’un fichier
#+end_note

** Commandes utiles en ligne de commande

*** grep

~grep~ cherche du texte dans un fichier ou dans la sortie d’une commande.

#+begin_src bash
grep "chien" animaux.txt          # cherche les lignes contenant "chien"
ls | grep ".sh"                    # filtre uniquement les fichiers .sh
grep -i "bonjour" fichier.txt     # ignore la casse
grep -r "maFonction" ./src              # recherche récursive dans un dossier
#+end_src

#+begin_caution Attention
La fonction ~grep~ permet d'utiliser des patternes Regex.

#+begin_note Les bases du Regex

#+begin_abstract - Les classes de caractère

- ~[abc]~ : un caractère, soit ~a~ soit ~b~ soit ~c~
- ~[^abc]~ : un caractère, sauf ~a~, ~b~ ou ~c~
- ~[a-c]~ : un caractère de ~a~ à ~c~
- ~[^a-c]~ : un caractère, sauf de ~a~ à ~c~
- ~[0-9~ : un nombre (aussi possible d'utiliser ~\d~)
- ~[a-cA-C]~ : un caractère de ~a~ à ~c~ ou ~A~ à ~C~

Il y a aussi les classes de caractères UNIX

- ~[[:alnum:]]~: tout les caractères (équivalent à ~[0-9A-Za-z]~)
- ~[[:alpha]]~ : tout les caractères (équivalent à ~[A-Za-z~)
- ~[[:digit:]]~ : tout les nombres (équivalent à ~[0-9]~)
- ~[[:lower:]] & [[:upper:]]~ tout les caractères en minuscules et majuscules
#+end_abstract

#+begin_abstract - Quantité
*Tout les quantificateurs supportent les classes de caractère*

- ~a?~ : zero ou un ~a~
- ~a*~ : zero ou plusieurs ~a~
- ~a+~ : un ou plusieurs ~a~
- ~a{4}~ : exactement 4 ~a~
- ~a{4,}~ : 4 ou plus de ~a~
- ~a{1,4}~ : entre 1 et 4 ~a~
#+end_abstract

#+begin_abstract - Séquences spéciales
Ces séquences permettent de définir des concepts et caractères non commun

- ~.~ : n'importe quel caractère unique
- ~\s~ : les espaces
- ~\S~ : les non espaces
- ~\d~ : les nombres
- ~\D~ : les non nombres
- ~R~ : les retour à la lignes

#+end_abstract

#+end_note
Pour plus d'info, allez sur [[https:quickref.me/regex][quickref : Regex]]
#+end_caution

*** tr

Change ou modifie les caractères (supporte les classes de caractères UNIX ~[:alpha]~ / ~[:alnum:]~...).

#+begin_src bash
echo "toto" | tr o 8 # renvoi t8t8
#+end_src

Il est possible d'utiliser une partie des classes UNIX

#+begin_src shell
echo "La commande tr permet de changer du texte" | tr [:lower:] [:upper:] # renvoi "lA COMMANDE TR PERMET DE CHANGER DU TEXTE"
#+end_src

*** cut

~cut~ découpe les lignes selon un délimiteur.

#+begin_src bash
cat data.csv | cut -d "," -f 1    # affiche la première colonne
#+end_src

#+begin_note Décomposition
- ~-d~ : donne le délimiteur à utiliser
- ~-f~ : quel field(s) à renvoyer (peut être une liste)
#+end_note

**** Exemple 

#+begin_src bash
echo "ceci,est,un,fichier,csv" > file.csv
cat file.csv | cut -d "," -f ,2,3
#+end_src

#+begin_conclusion - Résultat
ceci,est,un
#+end_conclusion

*** sort

Trie les lignes d’un fichier ou d’une commande.

#+begin_src bash
sort noms.txt             # tri alphabétique
sort -n notes.txt         # tri numérique
sort -r noms.txt          # tri inverse
#+end_src

*** uniq

Supprime les doublons (souvent combiné avec ~sort~).

#+begin_src bash
sort noms.txt | uniq
#+end_src

*** wc

Compte le nombre de lignes, mots, ou caractères.

#+begin_src bash
wc -l fichier.txt   # lignes
wc -w fichier.txt   # mots
wc -c fichier.txt   # caractères
#+end_src

*** tails

Renvoi les dernière ligne(s) d'un fichier

#+begin_src bash
tail -n 1 fichier.txt # lignes
#+end_src

*** head

Renvoi les première ligne(s) d'un fichier

#+begin_src bash
head -n 1 fichier.txt
#+end_src

*** awk

Permet de manipuler et formater des colonnes (langage de traitement de texte).

#+begin_src bash
awk '{print $1, $3}' data.txt       # affiche la 1re et 3e colonne
awk -F, '{print $2}' data.csv       # colonne 2 avec virgule comme séparateur
#+end_src

*** sed

Permet de rechercher et remplacer du texte.
La commande ~sed~ supporte aussi le Regex.

#+begin_src bash
sed 's/chat/chien/g' animaux.txt        # remplace "chat" par "chien"
sed -i 's/chien/loup/g' animaux.txt     # remplace directement dans le fichier
#+end_src
